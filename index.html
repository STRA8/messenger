<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>P2P Chat Room</title>
<style>
body { font-family: sans-serif; margin: 20px; }
#chat { border: 1px solid #ccc; height: 250px; overflow-y: auto; padding: 10px; margin-bottom: 10px; }
input, button { margin: 5px 0; width: 100%; }
.message { margin: 2px 0; }
.system { color: green; font-weight: bold; }
.sender { color: blue; }
.receiver { color: darkorange; }
</style>
</head>
<body>

<h2>P2P Chat Room</h2>

<label>Username (visual): <input type="text" id="username" placeholder="e.g. Alice"></label>
<label>Room ID: <input type="text" id="room" placeholder="e.g. abc123"></label>
<input type="text" id="message" placeholder="Type your message here">
<button id="sendBtn">Send</button>

<div id="chat"></div>

<script>
const workerUrl = "https://sparkling-wildflower-9369.devguywastaken.workers.dev/";

const chatDiv = document.getElementById("chat");
const sendBtn = document.getElementById("sendBtn");
const usernameInput = document.getElementById("username");
const roomInput = document.getElementById("room");
const msgInput = document.getElementById("message");

let pc, dc;
let connected = false;
let isHost = false;
let autoStarted = false;

function appendMessage(msg, type="message") {
    const p = document.createElement("p");
    p.textContent = msg;
    p.className = type;
    chatDiv.appendChild(p);
    chatDiv.scrollTop = chatDiv.scrollHeight;
}

async function sendSignal(room, data) {
    try { await fetch(workerUrl + "?id=" + room, {method:"POST", body:JSON.stringify(data)}); }
    catch(e){ console.error("Signal send failed:", e); }
}

async function pollSignal(room, username, onMessage) {
    while(!connected) {
        try {
            const res = await fetch(workerUrl + "?id=" + room);
            const text = await res.text();
            console.log("Raw response from worker:", text);

            let msgs;
            try { msgs = JSON.parse(text); } 
            catch(e) { console.error("Failed to parse JSON:", e); await new Promise(r => setTimeout(r, 1000)); continue; }

            for(const m of msgs) {
                if(m.from !== username) onMessage(m);
            }
        } catch(e){ console.error(e); }
        await new Promise(r => setTimeout(r, 1000));
    }
}

function startConnection() {
    const username = usernameInput.value.trim();
    const room = roomInput.value.trim();
    if(!username || !room) return;
    if(autoStarted) return;
    autoStarted = true;

    pc = new RTCPeerConnection({iceServers:[{urls:"stun:stun.l.google.com:19302"}]});
    console.log("RTCPeerConnection created");

    // Host creates the data channel
    if(!isHost) {
        dc = pc.createDataChannel("chat");
        dc.onopen = () => { 
            appendMessage("✅ Connected as host!", "system"); 
            connected = true; 
        };
        dc.onmessage = e => appendMessage(e.data, "receiver");
    }

    pc.onicecandidate = e => {
        console.log("ICE candidate:", e.candidate);
        if(e.candidate) sendSignal(room, {ice:e.candidate, from: username});
    };

    pc.onconnectionstatechange = () => {
        console.log("Connection state changed:", pc.connectionState);
    };

    // Guest listens for incoming data channel
    pc.ondatachannel = e => {
        dc = e.channel;
        dc.onopen = () => { appendMessage("✅ Connected as guest!", "system"); connected = true; };
        dc.onmessage = ev => appendMessage(ev.data, "receiver");
        dc.onclose = () => console.log("Data channel closed");
    };

    (async () => {
        if(isHost) {
            console.log("Hosting room:", room);
        } else {
            console.log("Joining room:", room);
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            await sendSignal(room, {sdp: offer, from: username});
        }

        pollSignal(room, username, async msg => {
            console.log("Incoming message:", msg);

            if(msg.sdp) {
                try {
                    if(!pc.currentRemoteDescription) {
                        await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
                        console.log("Remote SDP set:", msg.sdp.type);
                        if(msg.sdp.type === "offer") {
                            const answer = await pc.createAnswer();
                            await pc.setLocalDescription(answer);
                            await sendSignal(room, {sdp: answer, from: username});
                        }
                    }
                } catch(e) { console.error("Error setting remote SDP:", e); }
            }

            if(msg.ice) {
                try { await pc.addIceCandidate(new RTCIceCandidate(msg.ice)); } 
                catch(e) { console.error("Error adding ICE:", e); }
            }
        });
    })();
}

// Auto-connect when inputs are filled
usernameInput.addEventListener("input", startConnection);
roomInput.addEventListener("input", startConnection);

sendBtn.onclick = () => {
    const msg = msgInput.value.trim();
    if(!msg || !dc || dc.readyState!=="open") return;
    const username = usernameInput.value || "You";
    dc.send(`${username}: ${msg}`);
    appendMessage(`You: ${msg}`, "sender");
    msgInput.value = "";
}

// temporary: toggle host/guest for testing
document.addEventListener("keydown", e => { if(e.key === "h") isHost = !isHost; console.log("Host mode:", isHost); });
</script>

</body>
</html>
