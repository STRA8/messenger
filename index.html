<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Simple P2P Chat</title>
<style>
body { font-family: sans-serif; margin: 20px; }
.chat-container { max-width: 400px; margin: auto; }
.chat-log { border: 1px solid #ccc; height: 250px; overflow-y: auto; padding: 10px; margin-bottom: 10px; }
.input-group { margin-bottom: 10px; }
.input-group input { width: 100%; padding: 5px; box-sizing: border-box; }
.input-group button { width: 100%; padding: 5px; }
.message { margin: 2px 0; }
.message.you { font-weight: bold; }
.message.system { font-style: italic; color: gray; }
</style>
</head>
<body>

<div class="chat-container">
    <h2>P2P Chat Room</h2>

    <div class="input-group">
        <input class="username" type="text" placeholder="Your name (visual)">
    </div>
    <div class="input-group">
        <input class="room" type="text" placeholder="Room ID">
    </div>
    <div class="input-group">
        <input class="message-input" type="text" placeholder="Type your message here">
    </div>
    <div class="input-group">
        <button class="send-btn">Send</button>
    </div>

    <div class="chat-log"></div>
</div>

<script>
const workerUrl = "https://sparkling-wildflower-9369.devguywastaken.workers.dev/";

const chatLog = document.querySelector(".chat-log");
const usernameInput = document.querySelector(".username");
const roomInput = document.querySelector(".room");
const messageInput = document.querySelector(".message-input");
const sendBtn = document.querySelector(".send-btn");

let pc, dc;
let connected = false;
let iceQueue = [];
let isHost = false;

function appendMessage(text, type="") {
    const p = document.createElement("p");
    p.className = `message ${type}`;
    p.textContent = text;
    chatLog.appendChild(p);
    chatLog.scrollTop = chatLog.scrollHeight;
}

async function sendSignal(room, data) {
    try {
        await fetch(workerUrl + "?id=" + room, {
            method:"POST",
            body: JSON.stringify(data)
        });
    } catch(e){ console.error("signal send failed", e); }
}

async function pollSignal(room, username) {
    while(!connected) {
        try {
            const res = await fetch(workerUrl + "?id=" + room);
            const msgs = JSON.parse(await res.text());

            for(const m of msgs) {
                if(m.from === username) continue;

                if(m.sdp) {
                    if(!pc.currentRemoteDescription) {
                        await pc.setRemoteDescription(new RTCSessionDescription(m.sdp));
                        if(m.sdp.type === "offer") {
                            const answer = await pc.createAnswer();
                            await pc.setLocalDescription(answer);
                            await sendSignal(room, {sdp: answer, from: username});
                        }
                        for(const ice of iceQueue) if(ice.candidate) await pc.addIceCandidate(new RTCIceCandidate(ice));
                        iceQueue = [];
                    }
                }

                if(m.ice && m.ice.candidate) {
                    if(pc.remoteDescription) {
                        await pc.addIceCandidate(new RTCIceCandidate(m.ice));
                    } else {
                        iceQueue.push(m.ice);
                    }
                }
            }
        } catch(e){ console.error(e); }
        await new Promise(r => setTimeout(r, 500));
    }
}

async function startConnection() {
    const username = usernameInput.value.trim();
    const room = roomInput.value.trim();
    if(!username || !room) return;
    if(pc) return;

    // Check if room is empty -> first person is host
    const res = await fetch(workerUrl + "?id=" + room);
    const msgs = JSON.parse(await res.text());
    isHost = msgs.length === 0;

    pc = new RTCPeerConnection({iceServers:[{urls:"stun:stun.l.google.com:19302"}]});

    if(isHost) {
        dc = pc.createDataChannel("chat");
        dc.onmessage = e => appendMessage(e.data);
        dc.onopen = () => { appendMessage("✅ Connected as host!", "system"); connected = true; };
    } else {
        pc.ondatachannel = e => {
            dc = e.channel;
            dc.onmessage = e => appendMessage(e.data);
            dc.onopen = () => { appendMessage("✅ Connected as guest!", "system"); connected = true; };
        };
    }

    pc.onicecandidate = e => { if(e.candidate) sendSignal(room, {ice:e.candidate, from: username}); }

    if(isHost) {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await sendSignal(room, {sdp: offer, from: username});
    }

    pollSignal(room, username);
}

// auto-connect when user fills inputs
usernameInput.addEventListener("input", startConnection);
roomInput.addEventListener("input", startConnection);

sendBtn.onclick = () => {
    if(!connected) { appendMessage("⚠️ Not connected yet!", "system"); return; }
    const msg = messageInput.value.trim();
    if(!msg) return;
    const username = usernameInput.value || "You";
    dc.send(`${username}: ${msg}`);
    appendMessage(`You: ${msg}`, "you");
    messageInput.value = "";
};
</script>

</body>
</html>
