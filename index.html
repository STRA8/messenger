<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>P2P Chat Room</title>
<style>
body { font-family: sans-serif; margin: 20px; }
#chat { border: 1px solid #ccc; height: 250px; overflow-y: auto; padding: 10px; margin-bottom: 10px; }
input, button { margin: 5px 0; width: 100%; }
.status { font-weight: bold; color: blue; }
.message { margin: 2px 0; }
</style>
</head>
<body>

<h2>P2P Chat Room</h2>

<label>Username (visual): <input type="text" id="username" placeholder="Enter your name"></label>
<label>Room ID: <input type="text" id="room" placeholder="Enter room ID"></label>
<input type="text" id="message" placeholder="Type your message here">
<button id="sendBtn">Send</button>

<div id="chat"></div>

<script>
const workerUrl = "https://sparkling-wildflower-9369.devguywastaken.workers.dev/";

const chatDiv = document.getElementById("chat");
const sendBtn = document.getElementById("sendBtn");
const usernameInput = document.getElementById("username");
const roomInput = document.getElementById("room");
const msgInput = document.getElementById("message");

let pc, dc;
let connected = false;
let iceQueue = [];
let remoteSet = false;

// animated connecting
let connectDots = 0;
let connectInterval = null;

function append(msg, cls="message") {
    const p = document.createElement("p");
    p.textContent = msg;
    p.className = cls;
    chatDiv.appendChild(p);
    chatDiv.scrollTop = chatDiv.scrollHeight;
}

function startConnectingAnimation() {
    if(connectInterval) clearInterval(connectInterval);
    connectInterval = setInterval(() => {
        let dots = ".".repeat(connectDots % 4);
        append(`ðŸ”¹ Connecting${dots}`, "status");
        connectDots++;
    }, 1000);
}

function stopConnectingAnimation() {
    if(connectInterval) clearInterval(connectInterval);
    connectDots = 0;
}

async function sendSignal(room, data) {
    try { await fetch(workerUrl + "?id=" + room, {method:"POST", body:JSON.stringify(data)}); }
    catch(e){ append(`Signal send failed: ${e}`, "status"); }
}

async function pollSignal(room, username, onMessage) {
    while(!connected) {
        try {
            const res = await fetch(workerUrl + "?id=" + room);
            const text = await res.text();
            // append(`Raw: ${text}`,"status"); // optional debug
            let msgs;
            try { msgs = JSON.parse(text); } 
            catch(e){ await new Promise(r => setTimeout(r,1000)); continue; }
            for(const m of msgs){
                if(m.from !== username) onMessage(m);
            }
        } catch(e){ append(`Polling error: ${e}`, "status"); }
        await new Promise(r => setTimeout(r,1000));
    }
}

function autoConnect() {
    const username = usernameInput.value.trim();
    const room = roomInput.value.trim();
    if(!username || !room) return;
    if(pc) return;

    append(`ðŸ”¹ Starting connection as ${username}`, "status");
    startConnectingAnimation();

    pc = new RTCPeerConnection({iceServers:[{urls:"stun:stun.l.google.com:19302"}]});

    dc = pc.createDataChannel("chat");
    dc.onmessage = e => append(e.data);
    dc.onopen = () => {
        stopConnectingAnimation();
        append(`âœ… Connected to room!`, "status");
        connected = true;
        // flush any queued ICE
        for(const candidate of iceQueue) pc.addIceCandidate(new RTCIceCandidate(candidate));
        iceQueue = [];
    };

    pc.onicecandidate = e => { 
        if(e.candidate){
            if(remoteSet){
                sendSignal(room, {ice:e.candidate, from: username});
                append(`Sent ICE candidate`, "status");
            } else {
                iceQueue.push(e.candidate);
                append(`Queued ICE candidate (waiting for remote)`, "status");
            }
        }
    };

    (async () => {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await sendSignal(room, {sdp: offer, from: username});
        append("Sent local SDP offer", "status");

        pollSignal(room, username, async msg => {
            if(msg.sdp){
                if(!pc.currentRemoteDescription){
                    await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
                    remoteSet = true;
                    append(`Remote SDP set (${msg.sdp.type})`, "status");
                    if(msg.sdp.type === "offer"){
                        const answer = await pc.createAnswer();
                        await pc.setLocalDescription(answer);
                        await sendSignal(room, {sdp: answer, from: username});
                        append("Sent local SDP answer", "status");
                    }
                    // flush queued ICE
                    for(const candidate of iceQueue) pc.addIceCandidate(new RTCIceCandidate(candidate));
                    iceQueue = [];
                }
            }
            if(msg.ice){
                if(remoteSet){
                    await pc.addIceCandidate(new RTCIceCandidate(msg.ice));
                    append(`Added remote ICE candidate`, "status");
                } else {
                    iceQueue.push(msg.ice);
                    append(`Queued remote ICE candidate (waiting for remoteDescription)`, "status");
                }
            }
        });
    })();
}

sendBtn.onclick = () => {
    const msg = msgInput.value.trim();
    if(!msg) return;
    autoConnect(); // try to connect if not yet
    if(!dc || dc.readyState !== "open") return;
    const username = usernameInput.value;
    dc.send(`${username}: ${msg}`);
    append(`You: ${msg}`);
    msgInput.value = "";
}
</script>

</body>
</html>
